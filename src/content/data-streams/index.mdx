---
section: dataStreams
title: "Chainlink Data Streams"
isIndex: true
whatsnext:
  {
    "Learn the basics about how to retrieve Data Streams reports using the Streams Trade implementation": "/data-streams/getting-started",
    "Learn how to fetch and decode Data Streams reports using the Streams Direct implementation": "/data-streams/#",
    "Find the list of available Stream IDs.": "/data-streams/stream-ids",
    "Find the schema of data to expect from Data Streams reports.": "/data-streams/reference/report-schema",
  }
---

import { Aside, ClickToZoom } from "@components"

<Aside type="note" title="Mainnet Access">
  Chainlink Data Streams is available on Arbitrum Mainnet and Arbitrum Sepolia.
</Aside>

<Aside type="note" title="Talk to an expert">
  <a href="https://chainlinkcommunity.typeform.com/datastreams?#ref_id=docs">Contact us</a> to talk to an expert about
  integrating Chainlink Data Streams with your applications.
</Aside>

Chainlink Data Streams provides low-latency delivery of market data offchain that you can verify onchain. With Chainlink Data Streams, decentralized applications (dApps) now have on-demand access to high-frequency market data backed by decentralized and transparent infrastructure.

Traditional push-based oracles provide regular updates onchain when certain price thresholds or update time periods have been met. Chainlink Data Streams is built using a new pull-based oracle design that maintains trust-minimization using onchain verification.

## Comparison to push-based oracles

Chainlink's push-based oracles provide regular updates onchain. Chainlink Data Streams operates as a pull-based oracle where you can retrieve the data in a report and use it onchain any time. Verifying the report onchain confirms that the data was agreed upon and signed by the DON. While many applications benefit from push-based oracles and require data only after it has been verified onchain, some applications require access to data that is updated at a higher frequency and delivered with lower latency. Pull-based oracles deliver these benefits while still cryptographically signing the data to ensure its veracity.

<ClickToZoom
  src="/images/data-streams/push-based-vs-pull-based-oracles.webp"
  alt="Chainlink Data Streams - Push-Based vs Pull-Based Oracles"
/>

Additionally, pull-based oracles deliver data onchain more efficiently by retrieving and verifying the data only when the application needs it. For example, a decentralized exchange might retrieve a Data Streams report and verify the data onchain when a user executes a trade. A push-based oracle repeatedly delivers data onchain even when that data is not immediately required by users.

## Use cases

Pull-based oracles allow decentralized applications to access data that is updated at a high frequency and delivered with low latency, which enables several new use cases:

- **Perpetual Futures:** Low-latency data and frontrunning prevention enable onchain perpetual futures protocols that can compete on performance with centralized exchanges while still using more transparent and decentralized infrastructure.
- **Options:** Pull-based oracles allow timely and precise settlement of options contracts. Additionally, Data Streams provides more detailed market liquidity data that can support dynamic onchain risk management logic.
- **Prediction Markets:** Higher frequency data updates allow for applications where users can act quickly in response to real-time events and be confident in the accuracy of the data used in the settlement.

## Data Streams implementations

### Streams Trade: Using Data Streams with Chainlink Automation

When combined with [Chainlink Automation](/chainlink-automation/introduction), Chainlink Data Streams allows decentralized applications to automate trade execution, mitigate frontrunning, and limit bias or adverse incentives in executing non-user-triggered orders.

<ClickToZoom
  src="/images/data-streams/data-streams-trade-architecture.webp"
  alt="Chainlink Data Streams - Streams Trade Architecture"
/>

#### Example trading flow

One example of how to use Streams Trade is in a decentralized exchange. An example flow might work using the following process:

<ClickToZoom
  src="/images/data-streams/streams-trade-sequence-diagram.webp"
  alt="Chainlink Data Streams - Streams Trade Example Trading Flow"
/>

1. A user initiates a trade by confirming an `initiateTrade` transaction in their wallet.
1. The onchain contract for the decentralized exchange responds by emitting a Log Trigger event.
1. The Chainlink Automation upkeep monitors the contract for the event. When Automation detects the event, it runs the `checkLog` function specified in the upkeep contract. The upkeep is defined by the decentralized exchange.
1. The `checkLog` function uses a `revert` with a custom error called `StreamsLookup`. This approach aligns with [EIP-3668](https://eips.ethereum.org/EIPS/eip-3668#use-of-revert-to-convey-call-information) and conveys the required information through the data in the `revert` custom error.
1. Chainlink Automation monitors the `StreamsLookup` custom error that triggers Chainlink Data Streams to process the offchain data request. Chainlink Data Streams then returns the requested signed report in the `checkCallback` function for Chainlink Automation.
1. Chainlink Automation passes the report to the Automation Registry, which executes the `performUpkeep` function defined by the decentralized exchange. The report is included as a variable in the `performUpkeep` function.
1. The `performUpkeep` function calls the `verify` function on the Data Streams onchain verifier contract and passes the report as a variable.
1. The verifier contract returns a `verifierResponse` bytes value to the upkeep.
1. If the response indicates that the report is valid, the upkeep executes the user's requested trade. If the response is invalid, the upkeep rejects the trade and notifies the user.

This is one example of how you can combine Data Streams and Chainlink Automation, but the systems are highly configurable. You can write your own log triggers to initiate upkeeps on Chainlink Automation for various events. You can configure the `StreamsLookup` to retrieve multiple reports. You can configure the `performUpkeep` function to perform a wide variety of actions using the report.

Read the [Getting Started](/data-streams/getting-started) guide to learn how to build your own smart contract that retrieves reports from Chainlink Data Streams, using the Streams Trade implementation.

### Streams Direct: Using the Data Engine with your own bot

Streams Direct offers a direct approach to integrating low-latency and high-frequency data into your applications. You can use an off-chain API to fetch reports, a WebSocket connection to subscribe to report updates, and an on-chain smart contract to verify reports.

For instance, you can use Chainlink Data Streams with the Streams Direct implementation to display indicative pricing off-chain on your front end or with your bot to settle trades on-chain.

#### On-Demand Offchain Workflows

<ClickToZoom
  src="/images/data-streams/data-streams-on-demand-offchain-workflows.webp"
  alt="Chainlink Data Streams - Streams Direct On-Demand Offchain Workflows"
/>

Learn more about the [Streams Direct Architecture](/data-streams/architecture#streams-direct-architecture) or read this [guide](/data-streams/tutorials/streams-direct-api) to learn how to fetch and decode Data Streams reports using the Streams Direct implementation.
