---
section: vrf
title: "VRF-Enabled Mystery Box"
whatsnext:
  {
    "Review VRF best practices": "/vrf/v2/best-practices",
    "Learn how to test VRF dApps locally using a mock contract": "/vrf/v2/direct-funding/examples/test-locally",
    "Learn how to estimate VRF costs": "/vrf/v2/estimating-costs",
    "See the list of supported networks for VRF": "/vrf/v2/direct-funding/supported-networks",
  }
---

import { Aside, CodeSample } from "@components"
import { Tabs } from "@components/Tabs"

This is a template for NFT collection with a mystery box mechanic powered by [Chainlink VRF](https://vrf.chain.link/).

Smart contracts are based on the gas efficient [ERC721Psi](https://github.com/estarriolvetch/ERC721Psi) and are fully tested. It's super easy to deploy and configure with most of the steps automated in the deploy script.

Some of the key features of this template include private minting stage with a merkle tree, rate limited batch minting, delayed reveal with randomization technique to save gas, provenance hash to verify the authenticity of the metadata, royalties for secondary sales, and configurable parameters.

## Objective

<Aside type="caution" title="Disclaimer">
  This tutorial represents an example of using a Chainlink product or service and is provided to help you understand how
  to interact with Chainlink's systems and services so that you can integrate them into your own. This template is
  provided "AS IS" and "AS AVAILABLE" without warranties of any kind, has not been audited, and may be missing key
  checks or error handling to make the usage of the product more clear. Do not use the code in this example in a
  production environment without completing your own audits and application of best practices. Neither Chainlink Labs,
  the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due
  to errors in code.
</Aside>

## Before you begin

<Aside type="note" title="New to smart contract development?">
  If you are new to smart contract development, learn how to [Deploy Your First Smart
  Contract](/getting-started/deploy-your-first-contract).
</Aside>

Before you start this tutorial, complete the following items:

- Install [git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git). Run `git --version` to check the installation.
- Install [Nodejs](https://nodejs.org/en/) version 16 or later.
- Optionally, you can [install Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) and use it to run this example instead of using `npm`.
- [Create an Etherscan API key](https://docs.etherscan.io/getting-started/viewing-api-usage-statistics) if you do not already have one.
- Create an account with [Infura](https://www.infura.io/) or [Alchemy](https://www.alchemy.com/) to use as an RPC endpoint if you do not already have one.

## Setup the example

This tutorial requires several setup steps:

1. [Clone the example repo and install dependencies](#clone-the-example-repo-and-install-dependencies)
1. [Configure the Hardhat project](#configure-the-hardhat-project)

### Clone the example repo and install dependencies

Clone the repo and install all dependencies.

{/* prettier-ignore */}
<Tabs client:visible>
<Fragment slot="tab.1">npm</Fragment>
<Fragment slot="tab.2">yarn</Fragment>
<Fragment slot="panel.1">
```bash
git clone https://github.com/smartcontractkit/quickstarts-mysterybox.git && \
cd quickstarts-mysterybox && \
npm install
```
</Fragment>
<Fragment slot="panel.2">
```bash
git clone git@github.com:smartcontractkit/quickstarts-mysterybox.git && \
cd quickstarts-mysterybox && \
yarn install
```
</Fragment>
</Tabs>

### Configure your project

Copy the `.env.example` file to `.env` and fill in the values.

```bash
cp .env.example .env
```

Set the parameters for the NFT contract.

| Parameter               | Description                                                                                                               | Example               |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------- | --------------------- |
| `NFT_NAME`              | The name of the NFT collection                                                                                            | `MysteryBox`          |
| `NFT_SYMBOL`            | The symbol of the NFT collection                                                                                          | `BOX`                 |
| `NFT_UNREVEALED_URI`    | The metadata URI for all tokens before reveal                                                                             | `https://example.com` |
| `NFT_MAX_SUPPLY`        | The maximum number of tokens that can be minted                                                                           | `100`                 |
| `NFT_MAX_MINT_PER_USER` | The maximum number of tokens that can be minted per user address                                                          | `10`                  |
| `NFT_FEE`               | The fee for minting a token in ETH                                                                                        | `0.1`                 |
| `NFT_ROYALTY_BPS`       | The royalty fee for selling a token in basis points                                                                       | `500`                 |
| `VRF_SUBSCRIPTION_ID`   | A funded Chainlink VRF subscription ID. If you leave this blank, a new subscription will be created and funded on deploy. | `123`                 |

Next, set the parameters for the Hardhat project.

### Configure the Hardhat project

[Hardhat](https://hardhat.org/) is an Ethereum development environment that is used here to configure and deploy the mystery box contract. You need the following information:

- The [RPC URL for your deployment network](https://hardhat.org/hardhat-runner/docs/config#json-rpc-based-networks), using an [RPC node provider](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) such as [Infura](https://www.infura.io/) or [Alchemy](https://www.alchemy.com/).
- The [private key for your deployer account](https://hardhat.org/hardhat-runner/docs/guides/verifying#deploying-and-verifying-a-contract-in-the-sepolia-testnet). If your deployer account is in MetaMask, [export your private key from MetaMask](https://support.metamask.io/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key).
- An [Etherscan API key](https://hardhat.org/hardhat-runner/docs/guides/verifying#getting-an-api-key-from-etherscan) for contract verification. [Create an Etherscan API key](https://docs.etherscan.io/getting-started/viewing-api-usage-statistics) if you do not already have one.

| Parameter         | Description                                                 | Example                                    |
| ----------------- | ----------------------------------------------------------- | ------------------------------------------ |
| `NETWORK_RPC_URL` | The RPC URL for the network you want to deploy to.          | `https://goerli.infura.io/v3/your-api-key` |
| `PRIVATE_KEY`     | The private key of the account you want to deploy from.     | `0xabc123abc123abc123abc123abc123...`      |
| `ETHERSCAN_API`   | The API key for Etherscan needed for contract verification. | `ABC123ABC123ABC123ABC123ABC123ABC1`       |

## Test

To run the unit tests, run the following command:

```bash
npm run test
```

If you want to see gas usage, run the following command:

```bash
REPORT_GAS=true npm run test
```

For coverage reports, run the following command:

```bash
npm run coverage
```

## Deploy and run the example mystery box contract

Now that your example is configured, you can test, deploy, and run the example. Then, switch accounts to act as a user who is minting NFTs.

### Deploy the example contract

Run the `npx hardhat run` command and replace `<network>` with the network that you want to deploy to. The network must be configured in [`hardhat.config.ts`](https://github.com/smartcontractkit/chainlink-solutions-mysterybox/blob/main/hardhat.config.ts).

```bash
npx hardhat run scripts/deploy.ts --network <network>
```

In addition to deploying the contract, the deploy script will also:

1.  Create and fund a VRF subscription if one is not provided.

    {/* prettier-ignore */}
    <Aside type="note">
    Make sure the deployer account has enough LINK to fund the subscription. The initial funding amount is configured in [`network-config.ts`](https://github.com/smartcontractkit/chainlink-solutions-mysterybox/blob/main/network-config.ts). For testnets, you can use the [LINK faucet](https://faucets.chain.link/).

    [Estimate the minimum subscription balance](/vrf/v2/estimating-costs#estimate-minimum-subscription-balance) that VRF requires to process your randomness request. The minimum subscription balance provides a buffer against gas volatility, and only the actual cost of your request will be deducted from your account.

    If your subscription is underfunded, your VRF request will be [pending](/vrf/v2/subscription/ui#pending) for 24 hours. If this happens, check the [Subscription Manager](https://vrf.chain.link]) to see the additional balance needed.

    </Aside>

1.  Add the deployed contract address as a consumer to the VRF subscription.

    If you provided a subscription ID, make sure the deployer account is the owner of the subscription. Otherwise, comment out the `addVrfConsumer` function in the deploy script and add the contract address manually.

1.  Generate a [Merkle tree](https://ethereum.org/en/developers/tutorials/merkle-proofs-for-offline-data-integrity/#introduction) for the allowlist.
    Note: The merkle tree is generated from the address list in `scripts/data/whitelist.json` file. Leave the file empty if you don't want to do a private mint.
1.  Verify the contract on Etherscan. This is important to show users the source code for the contract so they can confirm how it works. If you want to skip this step during testing, comment out the `verify` function in the deploy script.

## Access control for minting

You can set up the minting for the mystery box in two modes: private and public. Use these modes to determine which users can mint tokens. The owner account can update this setting after deployment, so you can test the opening functionality privately before making the mystery box available to the public.

### Enable private minting

The contract is by default in private mode after deployment. This means that only addresses on the allowlist can mint tokens. The list of allowed addresses is stored in a merkle tree. The merkle tree is generated from the address list in `scripts/data/whitelist.json` file.

Minting tokens in private mode is done by calling the `privateMint` function. The function takes the following parameters:

- `amount` The amount of tokens to mint.
- `proof` The merkle proof for the user's address.

You can generate the Merkle proof locally using [merkletreejs](https://github.com/merkletreejs/merkletreejs):

```js
merkleTree.getHexProof(keccak256(whitelistedUserAddress))
```

### Enable public minting

To enable public minting:

1. Leave the `scripts/data/whitelist.json` file empty.
1. Call the `setPublicMint` function with `true` as the parameter.

Minting tokens in public mode is done by calling the `publicMint` function. The function takes the following parameters:

- `amount` The amount of tokens to mint.

Each address can only mint a maximum of `NFT_MAX_MINT_PER_USER` tokens.

## Metadata

NFT metadata is the standard description of an asset which allows applications (like wallets and marketplaces) to present them with rich data. You can learn more about this in the [Metadata Standards](https://docs.opensea.io/docs/metadata-standards) Guide by OpenSea.

Because of the [randomization technique](https://mirror.xyz/ctor.xyz/ZEY5-wn-3EeHzkTUhACNJZVKc0-R6EsDwwHMr5YJEn0) used, the actual metadata for each token can be known before the reveal. So it is safe to set the `baseURI` in advance.

This creates additional trust for the users because they can verify the metadata before minting.

### Storage options

The metadata for each token is stored in a JSON file and must be hosted somewhere. You can use any storage provider you want. Here are some options:

- Decentralized
  - [IPFS](https://ipfs.io/)
  - [Arweave](https://www.arweave.org/)
  - [Pinata](https://pinata.cloud/)
- Centralized
  - [AWS S3](https://aws.amazon.com/s3/)
  - [Google Cloud Storage](https://cloud.google.com/storage)

Alternatiely, you can build a metadata server that serves the metadata for each token. Here's an example of a [metadata server](https://github.com/ProjectOpenSea/metadata-api-nodejs) built by OpenSea.

## Provenance

The provenance hash is a hash of the collection's metadata. It is used to verify the authenticity of the collection in addition to the metadata known before reveal.

It should be computed off-chain by SHA256 hashing every image, concatenating the hashes and then SHA256 hashing the combined string too. The resulting hash should be set as the provenance hash by calling the `setProvenanceHash` function.

Learn more about the elegance of the provenance hash in this [blog post](https://blog.0xproject.com/the-elegance-of-the-provenance-hash-4d8d9b2a0b0e).

## Reveal

To reveal the NFTs, call the `reveal` function from the owner account. It will create a Chainlink VRF request to generate a random seed.

When the request is fulfilled, the NFTs metadata for each token will be randomized with the seed provided.

The token URI will also start to use the `baseURI` instead of the `unrevealedURI`, so make sure to call the `setBaseURI` function before calling the `reveal` function.

Once the collection is revealed, the minting functions will be disabled.

## Withdraw funds

At any time, the owner can withdraw funds from the collected fees by calling the `withdraw` function. By doing so, the contract balance will be transferred to the owner account.

## Post-deployment configuration

After deployment, you can optionally change some contract parameters by calling the following functions from the owner account:

| Function            | Description                              | Parameters           |
| ------------------- | ---------------------------------------- | -------------------- |
| `setBaseURI`        | Set the base URI for the token metadata. | `newBaseURI`         |
| `setMintFee`        | Set new mint fee.                        | `fee`                |
| `setWhitelistRoot`  | Set new merkle root for the whitelist.   | `whitelistRoot`      |
| `setProvenanceHash` | Set new provenance hash.                 | `provenanceHash`     |
| `setRoyalty`        | Set new royalty receiver and fee.        | `receiver`, `feeBps` |
| `setPublicMint`     | Enable/disable public minting.           | `publicMintEnabled`  |
